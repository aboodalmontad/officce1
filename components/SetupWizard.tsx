import * as React from 'react';
import { ClipboardDocumentIcon, ClipboardDocumentCheckIcon } from './icons';

interface SetupWizardProps {
    onRetry: () => void;
}

const sqlScript = `-- This script is intended to be run directly in the Supabase SQL Editor.
-- Version 15.0: Added delete_user_account function.

-- 1. CLEANUP: Drop all existing objects in reverse order of dependency.
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT 'DROP POLICY IF EXISTS "' || policyname || '" ON public.' || tablename || ';' as statement FROM pg_policies WHERE schemaname = 'public') LOOP
        EXECUTE r.statement;
    END LOOP;
END$$;

DROP FUNCTION IF EXISTS public.delete_user_account() CASCADE;
DROP FUNCTION IF EXISTS public.is_admin() CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.full_db_setup(params jsonb) CASCADE;
DROP TABLE IF EXISTS public.site_finances CASCADE;
DROP TABLE IF EXISTS public.invoice_items CASCADE;
DROP TABLE IF EXISTS public.invoices CASCADE;
DROP TABLE IF EXISTS public.sessions CASCADE;
DROP TABLE IF EXISTS public.stages CASCADE;
DROP TABLE IF EXISTS public.cases CASCADE;
DROP TABLE IF EXISTS public.clients CASCADE;
DROP TABLE IF EXISTS public.admin_tasks CASCADE;
DROP TABLE IF EXISTS public.appointments CASCADE;
DROP TABLE IF EXISTS public.accounting_entries CASCADE;
DROP TABLE IF EXISTS public.assistants CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 2. HELPER FUNCTIONS
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $is_admin_body$
DECLARE
    user_role TEXT;
BEGIN
    -- Check the user's role from their profile. This is more reliable than JWT metadata.
    SELECT role INTO user_role FROM public.profiles WHERE id = auth.uid();
    RETURN COALESCE(user_role, 'user') = 'admin';
END;
$is_admin_body$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- 3. TABLES CREATION
CREATE TABLE public.profiles (id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, full_name text, mobile_number text UNIQUE, is_approved boolean DEFAULT false, is_active boolean DEFAULT true, subscription_start_date date, subscription_end_date date, role text DEFAULT 'user');
CREATE TABLE public.assistants (id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, name text NOT NULL, UNIQUE(user_id, name));
CREATE TABLE public.clients (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, name text NOT NULL, contact_info text);
CREATE TABLE public.cases (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, client_id text NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE, subject text NOT NULL, client_name text, opponent_name text, fee_agreement text, status text DEFAULT 'active');
CREATE TABLE public.stages (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, case_id text NOT NULL REFERENCES public.cases(id) ON DELETE CASCADE, court text NOT NULL, case_number text, first_session_date timestamptz, decision_date timestamptz, decision_number text, decision_summary text, decision_notes text);
CREATE TABLE public.sessions (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, stage_id text NOT NULL REFERENCES public.stages(id) ON DELETE CASCADE, court text, case_number text, date timestamptz NOT NULL, client_name text, opponent_name text, postponement_reason text, next_postponement_reason text, is_postponed boolean DEFAULT false, next_session_date timestamptz, assignee text);
CREATE TABLE public.admin_tasks (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, task text NOT NULL, due_date timestamptz NOT NULL, completed boolean DEFAULT false, importance text DEFAULT 'normal', assignee text, location text);
CREATE TABLE public.appointments (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, title text NOT NULL, "time" text, date timestamptz NOT NULL, importance text, notified boolean, reminder_time_in_minutes integer, assignee text);
CREATE TABLE public.accounting_entries (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, type text NOT NULL, amount real NOT NULL, date timestamptz NOT NULL, description text, client_id text, case_id text, client_name text);
CREATE TABLE public.invoices (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, client_id text NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE, client_name text, case_id text REFERENCES public.cases(id) ON DELETE SET NULL, case_subject text, issue_date timestamptz NOT NULL, due_date timestamptz NOT NULL, tax_rate real DEFAULT 0, discount real DEFAULT 0, status text DEFAULT 'draft', notes text);
CREATE TABLE public.invoice_items (id text NOT NULL PRIMARY KEY, user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, invoice_id text NOT NULL REFERENCES public.invoices(id) ON DELETE CASCADE, description text NOT NULL, amount real NOT NULL);
CREATE TABLE public.site_finances (id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL, payment_date date NOT NULL, amount real NOT NULL, description text, payment_method text);


-- 4. AUTOMATION
-- Trigger function for new user signup.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $handle_new_user_body$
DECLARE
  mobile_num TEXT;
  profile_count INT;
  new_role TEXT;
  auto_approve BOOLEAN;
BEGIN
  -- Extract mobile number from custom user metadata.
  mobile_num := new.raw_user_meta_data->>'mobile_number';

  -- Determine role: first user is admin, others are users.
  SELECT count(*) INTO profile_count FROM public.profiles;
  IF profile_count = 0 THEN
    new_role := 'admin';
    auto_approve := true; -- Admins are approved by default.
  ELSE
    new_role := 'user';
    auto_approve := false;
  END IF;

  -- Bypass RLS to perform administrative inserts/deletes into the profiles table.
  SET session_replication_role = 'replica';

  -- Delete a potentially orphaned profile with the same mobile number to prevent unique constraint violations.
  IF mobile_num IS NOT NULL THEN
    DELETE FROM public.profiles WHERE mobile_number = mobile_num;
  END IF;
  
  -- Insert the new profile with the determined role and approval status.
  INSERT INTO public.profiles (id, full_name, mobile_number, role, is_approved, is_active)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', mobile_num, new_role, auto_approve, true);

  -- Restore standard RLS behavior for the rest of the session.
  SET session_replication_role = 'origin';
  
  -- Set the custom role claim in the auth schema for the JWT.
  UPDATE auth.users
  SET raw_app_meta_data = COALESCE(raw_app_meta_data, '{}'::jsonb) || jsonb_build_object('role', new_role)
  WHERE id = new.id;
  
  RETURN new;
END;
$handle_new_user_body$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, auth;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to allow users to delete their own account.
CREATE OR REPLACE FUNCTION public.delete_user_account()
RETURNS void AS $$
BEGIN
  -- This will cascade delete all related data in public schema due to schema setup.
  DELETE FROM auth.users WHERE id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 5. SECURITY: RLS POLICIES
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.assistants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cases ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.appointments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.accounting_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.site_finances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles FORCE ROW LEVEL SECURITY;

CREATE POLICY "Enable ALL for admin on profiles" ON public.profiles FOR ALL USING (is_admin()) WITH CHECK (is_admin());
CREATE POLICY "Enable read access for own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Enable update for own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
CREATE POLICY "Enable insert for own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow deleting own profile" ON public.profiles FOR DELETE USING (auth.uid() = id);

CREATE POLICY "Enable ALL for admin on site_finances" ON public.site_finances FOR ALL USING (is_admin()) WITH CHECK (is_admin());
CREATE POLICY "Enable read for own site_finances" ON public.site_finances FOR SELECT USING (auth.uid() = user_id);

DO $policy_loop$
DECLARE
    table_name TEXT;
BEGIN
    FOR table_name IN 
        SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND tablename IN 
        ('assistants', 'clients', 'cases', 'stages', 'sessions', 'admin_tasks', 'appointments', 'accounting_entries', 'invoices', 'invoice_items')
    LOOP
        EXECUTE format('
          CREATE POLICY "Enable ALL for admin on %I" ON public.%I FOR ALL USING (is_admin()) WITH CHECK (is_admin());
          CREATE POLICY "Enable ALL for own data on %I" ON public.%I FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
        ', table_name, table_name, table_name, table_name);
    END LOOP;
END $policy_loop$;

-- 6. PERMISSIONS
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role;
GRANT EXECUTE ON FUNCTION public.is_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION public.delete_user_account() TO authenticated;

-- Permissions for the SECURITY DEFINER trigger
GRANT USAGE ON SCHEMA auth TO postgres;
GRANT SELECT ON TABLE auth.users TO postgres;
GRANT UPDATE (raw_app_meta_data) ON TABLE auth.users TO postgres;

-- 7. POST-SETUP FIX: Manually confirm all existing users.
-- This is a fallback to resolve issues if "Confirm email" was enabled during user creation.
UPDATE auth.users SET email_confirmed_at = NOW() WHERE email_confirmed_at IS NULL;

-- Final confirmation message for direct execution.
SELECT 'Database setup complete! Version 15.0 (Added delete user account function)' as result;
`;

const SetupWizard: React.FC<SetupWizardProps> = ({ onRetry }) => {
    const [copied, setCopied] = React.useState(false);

    const handleCopy = () => {
        navigator.clipboard.writeText(sqlScript).then(() => {
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
        });
    };

    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4" dir="rtl">
            <div className="w-full max-w-4xl p-8 space-y-6 bg-white rounded-lg shadow-md">
                <div className="text-center">
                    <h1 className="text-3xl font-bold text-gray-800">تهيئة قاعدة البيانات</h1>
                    <p className="mt-2 text-gray-600">
                        يبدو أن قاعدة البيانات غير مهيأة بشكل صحيح. يرجى اتباع الخطوات التالية لإعدادها.
                    </p>
                </div>

                <div className="space-y-4 text-gray-700">
                    <p>
                        <strong className="font-semibold text-gray-800">الخطوة 1:</strong> اذهب إلى لوحة تحكم مشروعك في Supabase.
                    </p>
                    <p>
                        <strong className="font-semibold text-gray-800">الخطوة 2:</strong> من القائمة الجانبية، اختر <span className="font-mono bg-gray-200 px-1.5 py-0.5 rounded-md text-sm">SQL Editor</span>.
                    </p>
                    <p>
                        <strong className="font-semibold text-gray-800">الخطوة 3:</strong> انسخ الشيفرة التالية بالكامل والصقها في المحرر.
                    </p>
                </div>

                <div className="relative">
                    <pre className="bg-gray-800 text-white p-4 rounded-lg overflow-x-auto text-sm max-h-64" dir="ltr">
                        <code>
                            {sqlScript}
                        </code>
                    </pre>
                    <button 
                        onClick={handleCopy}
                        className="absolute top-3 left-3 flex items-center gap-2 px-3 py-1 bg-gray-600 text-white text-xs font-semibold rounded-lg hover:bg-gray-700 transition-colors"
                    >
                        {copied ? <ClipboardDocumentCheckIcon className="w-4 h-4 text-green-400" /> : <ClipboardDocumentIcon className="w-4 h-4" />}
                        {copied ? 'تم النسخ' : 'نسخ الشيفرة'}
                    </button>
                </div>

                <div className="space-y-4 text-gray-700">
                     <p>
                        <strong className="font-semibold text-gray-800">الخطوة 4:</strong> اضغط على زر "RUN" لتنفيذ الشيفرة.
                    </p>
                    <p>
                        <strong className="font-semibold text-gray-800">الخطوة 5:</strong> بعد اكتمال التنفيذ بنجاح، عد إلى هنا واضغط على زر "إعادة المحاولة".
                    </p>
                </div>

                <div className="text-center pt-4">
                    <button 
                        onClick={onRetry}
                        className="px-8 py-3 text-lg font-semibold text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition-colors"
                    >
                        إعادة المحاولة
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SetupWizard;